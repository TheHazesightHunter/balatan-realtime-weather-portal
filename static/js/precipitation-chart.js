class PrecipitationChart {
	constructor(config) {
		this.chartId = config.chartId || "precipitationChart";
		this.apiEndpoint = config.apiEndpoint || "/api/precipitation-data";
		this.showControls = config.showControls !== false;
		this.autoLoad = config.autoLoad !== false;

		if (
			!config.stationConfig ||
			Object.keys(config.stationConfig).length === 0
		) {
			throw new Error("[CHART] stationConfig is required!");
		}
		this.stationConfig = config.stationConfig;

		this.onDataLoaded = config.onDataLoaded || null;

		// Internal state
		this.chart = null;
		this.chartData = null;
		this.dateRange = null;
		this.elements = {};
		this.weatherIcons = [];
		this._resizeTimer = null;
		this._resizeHandler = null;
		this._retryTimeout = null;
		this._loadDebounceTimer = null; // NEW: For debouncing

		// Sliding state
		this.currentPage = 0;
		this.totalPages = 2;
		this.hoursPerPage = 12;
		this.dataCache = new Map(); // Cache for loaded data

		console.log(`[${this.chartId}] Chart initialized`);
	}

	// =========================================================================
	// RESPONSIVE HELPERS
	// =========================================================================

	_isMobile() {
		return window.innerWidth < 768;
	}

	_getResponsiveDimensions() {
		const width = window.innerWidth;

		if (width < 480) {
			return {
				height: 250,
				fontSize: 10,
				iconSize: 20,
				lineThickness: 2,
				markerSize: 4,
			};
		}
		if (width < 768) {
			return {
				height: 280,
				fontSize: 11,
				iconSize: 28,
				lineThickness: 2.5,
				markerSize: 5,
			};
		}
		if (width < 1024) {
			return {
				height: 320,
				fontSize: 12,
				iconSize: 32,
				lineThickness: 3,
				markerSize: 6,
			};
		}
		return {
			height: 400,
			fontSize: 12,
			iconSize: 36,
			lineThickness: 3,
			markerSize: 6,
		};
	}

	// =========================================================================
	// INITIALIZATION
	// =========================================================================

	async init() {
		console.log(`[${this.chartId}] Setting up...`);

		this._cacheElements();

		if (!this.elements.chartContainer) {
			console.error(`[${this.chartId}] Chart container not found!`);
			return;
		}

		const container = this.elements.chartContainer;
		const computedStyle = window.getComputedStyle(container);
		if (computedStyle.position === "static") {
			container.style.position = "relative";
		}

		this._setupResizeHandler();

		if (this.showControls) {
			await this._loadDateRange();
		}

		if (this.autoLoad) {
			this.loadLatestData();
		}
	}

	_cacheElements() {
		this.elements = {
			chartContainer: document.getElementById(this.chartId),
			loading: document.getElementById("chart-loading"),
			error: document.getElementById("chart-error"),
			errorMessage: document.getElementById("chart-error-message"),
			dateBadge: document.getElementById("chart-date-display"),
			datePicker: document.getElementById("datePicker"),
		};
	}

	_setupResizeHandler() {
		this._resizeHandler = () => {
			if (this._resizeTimer) clearTimeout(this._resizeTimer);
			this._resizeTimer = setTimeout(() => {
				// FIXED: Use optimized render instead of full rebuild
				if (this.chart) {
					const dims = this._getResponsiveDimensions();
					this.chart.options.height = dims.height;
					this.chart.options.axisX.labelFontSize = dims.fontSize;
					this.chart.options.axisY.labelFontSize = dims.fontSize;
					this.chart.options.axisX.titleFontSize = dims.fontSize + 2;
					this.chart.options.axisY.titleFontSize = dims.fontSize + 2;
					this.chart.options.legend.fontSize = dims.fontSize;

					// Update data series dimensions
					if (this.chart.options.data) {
						this.chart.options.data.forEach((series) => {
							series.lineThickness = dims.lineThickness;
							series.markerSize = dims.markerSize;
						});
					}

					this.chart.render(); // Just re-render, don't rebuild
					this._positionWeatherIcons(); // Reposition icons
				}
			}, 250);
		};
		window.addEventListener("resize", this._resizeHandler);
	}

	// =========================================================================
	// PUBLIC API
	// =========================================================================

	loadLatestData() {
		this._loadPrecipitationData();
	}

	loadSpecificDate(dateString) {
		console.log(`[${this.chartId}] Loading date: ${dateString}`);
		this.currentPage = 0;

		// NEW: Debounce rapid date changes
		if (this._loadDebounceTimer) {
			clearTimeout(this._loadDebounceTimer);
		}

		this._loadDebounceTimer = setTimeout(() => {
			this._loadPrecipitationData(dateString);
		}, 300);

		// Return a promise so calling code can use .finally()
		return new Promise((resolve) => {
			const originalCallback = this.onDataLoaded;
			this.onDataLoaded = (data) => {
				if (originalCallback) originalCallback(data);
				resolve(data);
			};
		});
	}

	retry() {
		this._hideError();
		this.loadLatestData();
	}

	refresh() {
		// Clear cache for current date and reload
		if (this.chartData && this.chartData.date) {
			this.dataCache.delete(this.chartData.date);
		}
		this.loadLatestData();
	}

	destroy() {
		if (this._resizeTimer) clearTimeout(this._resizeTimer);
		if (this._retryTimeout) clearTimeout(this._retryTimeout);
		if (this._loadDebounceTimer) clearTimeout(this._loadDebounceTimer);
		if (this._resizeHandler) {
			window.removeEventListener("resize", this._resizeHandler);
		}
		this._clearWeatherIcons();
		if (this.chart) this.chart.destroy();
		this.chartData = null;
		this.dateRange = null;
		this.dataCache.clear();
		this.elements = {};
	}

	getCurrentData() {
		return this.chartData;
	}

	// =========================================================================
	// DATA LOADING
	// =========================================================================

	async _loadDateRange() {
		try {
			const response = await fetch("/api/precipitation-date-range");

			// FIXED: Better error handling
			if (!response.ok) {
				let errorMessage = `HTTP ${response.status}`;
				try {
					const errorData = await response.json();
					errorMessage = errorData.error || errorMessage;
				} catch (parseError) {
					console.warn("[CHART] Could not parse error response as JSON");
				}
				throw new Error(errorMessage);
			}

			const data = await response.json();
			if (!data.success) throw new Error(data.error || "Invalid date range");

			this.dateRange = {
				earliest: data.earliest_date,
				latest: data.latest_date,
				earliestDisplay: data.earliest_display,
				latestDisplay: data.latest_display,
			};

			if (this.elements.datePicker) {
				this.elements.datePicker.min = this.dateRange.earliest;
				this.elements.datePicker.max = this.dateRange.latest;
				this.elements.datePicker.value = this.dateRange.latest;
			}
		} catch (error) {
			console.warn(`[${this.chartId}] Date range error:`, error);
		}
	}

	async _loadPrecipitationData(dateString = null) {
		// NEW: Check cache first
		if (dateString && this.dataCache.has(dateString)) {
			console.log(
				`[${this.chartId}] Ã¢Å“â€œ Using cached data for ${dateString}`
			);
			const cachedData = this.dataCache.get(dateString);
			this.chartData = cachedData;

			if (this.elements.dateBadge) {
				this.elements.dateBadge.textContent = cachedData.date_display;
			}

			this._renderChart(cachedData);

			if (typeof this.onDataLoaded === "function") {
				this.onDataLoaded(cachedData);
			}

			return cachedData;
		}

		return this._loadWithRetry(dateString, 1);
	}

	async _loadWithRetry(dateString, attempt) {
		const MAX_RETRIES = 3;
		const RETRY_DELAYS = [1000, 2000, 5000];

		this._showLoading();

		try {
			const apiUrl = dateString
				? `${this.apiEndpoint}?date=${dateString}`
				: this.apiEndpoint;

			const response = await fetch(apiUrl);

			// FIXED: Improved error handling for non-JSON responses
			if (!response.ok) {
				let errorMessage = `HTTP ${response.status}`;
				try {
					const errorData = await response.json();
					errorMessage = errorData.error || errorMessage;
				} catch (parseError) {
					// Response wasn't JSON (probably HTML error page)
					console.error("[CHART] Non-JSON error response:", parseError);
					errorMessage = `Server error (${response.status}). Please try again.`;
				}
				throw new Error(errorMessage);
			}

			const data = await response.json();

			if (!data.success) {
				if (data.retry_in && attempt < MAX_RETRIES) {
					await this._sleep(data.retry_in * 1000);
					return this._loadWithRetry(dateString, attempt + 1);
				}
				throw new Error(data.error || "Failed to load data");
			}

			const hasData = Object.values(data.stations).some(
				(station) => station.data && station.data.length > 0
			);

			if (!hasData) {
				throw new Error(`No data available for ${data.date_display}`);
			}

			this.chartData = data;

			// NEW: Cache the data
			if (data.date) {
				this.dataCache.set(data.date, data);
				console.log(`[${this.chartId}] Ã¢Å“â€œ Cached data for ${data.date}`);
			}

			if (this.elements.dateBadge) {
				this.elements.dateBadge.textContent = data.date_display;
			}

			this._renderChart(data);
			this._hideLoading();

			if (typeof this.onDataLoaded === "function") {
				this.onDataLoaded(data);
			}

			return data;
		} catch (error) {
			console.error(`[${this.chartId}] Ã¢ÂÅ’ Error:`, error);

			if (attempt < MAX_RETRIES) {
				const retryDelay = RETRY_DELAYS[attempt - 1];
				this._showRetryMessage(attempt, MAX_RETRIES, retryDelay);
				await this._sleep(retryDelay);
				return this._loadWithRetry(dateString, attempt + 1);
			} else {
				this._showError(
					`Unable to load data after ${MAX_RETRIES} attempts. ` +
						`Please check your connection and try again.`
				);
			}
		}
	}

	_sleep(ms) {
		return new Promise((resolve) => {
			this._retryTimeout = setTimeout(resolve, ms);
		});
	}

	_showRetryMessage(attempt, maxAttempts, delayMs) {
		const seconds = Math.ceil(delayMs / 1000);
		const message = `Retrying ${attempt}/${maxAttempts} in ${seconds}s...`;

		if (this.elements.loading) {
			let loadingText = this.elements.loading.querySelector(
				".chart-loading__text"
			);
			if (loadingText) {
				loadingText.textContent = message;
			}
		}
	}

	// =========================================================================
	// CHART RENDERING
	// =========================================================================

	_renderChart(apiData) {
		const isMobile = this._isMobile();
		const dataSeries = [];

		for (const stationId in apiData.stations) {
			const stationData = apiData.stations[stationId];
			const config = this.stationConfig[stationId];

			if (!config) {
				console.warn(`No config for station: ${stationId}`);
				continue;
			}

			const allDataPoints = stationData.data.map((point) => ({
				label: point.label,
				y: point.y,
				actualLabel: point.label,
				day: point.day,
				stationName: config.name,
			}));

			const dataPoints = isMobile
				? this._getDataPointsForCurrentPage(allDataPoints)
				: allDataPoints;

			dataSeries.push({
				type: "spline",
				name: config.name,
				showInLegend: true,
				visible: true,
				color: config.color,
				dataPoints: dataPoints,
				stationId: stationId,
			});
		}

		if (this.chart) {
			this._updateChart(dataSeries);
		} else {
			this._createNewChart(dataSeries);
		}

		this._updateNavigationButtons();
	}

	_getDataPointsForCurrentPage(allDataPoints) {
		const startIndex = this.currentPage * this.hoursPerPage;
		const endIndex = startIndex + this.hoursPerPage;
		return allDataPoints.slice(startIndex, endIndex);
	}

	_updateChart(dataSeries) {
		const dims = this._getResponsiveDimensions();

		this._clearWeatherIcons();

		this.chart.options.height = dims.height;
		this.chart.options.axisX.labelFontSize = dims.fontSize;
		this.chart.options.axisY.labelFontSize = dims.fontSize;
		this.chart.options.axisX.titleFontSize = dims.fontSize + 2;
		this.chart.options.axisY.titleFontSize = dims.fontSize + 2;
		this.chart.options.legend.fontSize = dims.fontSize;

		this.chart.options.data = dataSeries.map((series) => ({
			...series,
			lineThickness: dims.lineThickness,
			markerSize: dims.markerSize,
		}));

		this.chart.render();
		setTimeout(() => this._addWeatherIcons(), 100);
	}

	_createNewChart(dataSeries) {
		const self = this;
		const dims = this._getResponsiveDimensions();

		this.chart = new CanvasJS.Chart(this.chartId, {
			animationEnabled: true,
			animationDuration: 400,
			theme: "light1",
			height: dims.height,

			title: {
				text: "",
				fontSize: 0,
			},

			axisX: {
				title: "Time of Day",
				titleFontSize: dims.fontSize + 2,
				labelFontSize: dims.fontSize,
				labelFontColor: "#64748b",
				lineColor: "#e2e8f0",
				tickColor: "#e2e8f0",
				interval: 2,
			},

			axisY: {
				title: "Rainfall (mm/hr)",
				titleFontSize: dims.fontSize + 2,
				labelFontSize: dims.fontSize,
				labelFontColor: "#64748b",
				lineColor: "#e2e8f0",
				tickColor: "#e2e8f0",
				gridColor: "#f1f5f9",
				gridThickness: 1,
				minimum: 0,
				suffix: " mm",
			},

			toolTip: {
				shared: true,
				contentFormatter: (e) => this._formatTooltip(e),
				borderThickness: 0,
				borderColor: "transparent",
				cornerRadius: 12,
				backgroundColor: "transparent",
				animationEnabled: false,
			},

			legend: {
				cursor: "pointer",
				itemclick: function (e) {
					e.dataSeries.visible =
						typeof e.dataSeries.visible === "undefined"
							? false
							: !e.dataSeries.visible;
					e.chart.render();
					setTimeout(() => self._addWeatherIcons(), 100);
				},
				fontSize: dims.fontSize,
				fontWeight: 500,
				fontColor: "#475569",
				horizontalAlign: "center",
				verticalAlign: "bottom",
				markerType: "circle",
				markerMargin: 8,
			},

			data: dataSeries.map((series) => ({
				...series,
				lineThickness: dims.lineThickness,
				markerSize: dims.markerSize,
			})),
		});

		this.chart.render();
		setTimeout(() => this._addWeatherIcons(), 100);

		if (this._isMobile()) {
			this._setupTouchGestures();
		}
	}

	// =========================================================================
	// CONTINUOUS SLIDING (LIKE CARROT!)
	// =========================================================================

	async slidePrev() {
		if (this.currentPage > 0) {
			this.currentPage--;
			this._renderChart(this.chartData);
			console.log(`[CHART] Ã¢â€ Â Slid to ${this._getWindowLabel()}`);
		} else {
			await this._slideToPreviousDate();
		}
	}

	async slideNext() {
		if (this.currentPage < this.totalPages - 1) {
			this.currentPage++;
			this._renderChart(this.chartData);
			console.log(`[CHART] Ã¢â€ â€™ Slid to ${this._getWindowLabel()}`);
		} else {
			await this._slideToNextDate();
		}
	}

	async _slideToPreviousDate() {
		if (!this.dateRange || !this.chartData) return;

		const currentDate = new Date(this.chartData.date);
		const prevDate = new Date(currentDate);
		prevDate.setDate(prevDate.getDate() - 1);
		const prevDateStr = this._formatDate(prevDate);

		if (prevDateStr < this.dateRange.earliest) {
			console.log("[CHART] At earliest date");
			return;
		}

		console.log(`[CHART] Loading previous date: ${prevDateStr}`);
		await this._loadPrecipitationData(prevDateStr);
		this.currentPage = this.totalPages - 1;
		this._renderChart(this.chartData);
		console.log(`[CHART] Ã¢â€ Â Slid to ${prevDateStr} PM`);
	}

	async _slideToNextDate() {
		if (!this.dateRange || !this.chartData) return;

		const currentDate = new Date(this.chartData.date);
		const nextDate = new Date(currentDate);
		nextDate.setDate(nextDate.getDate() + 1);
		const nextDateStr = this._formatDate(nextDate);

		if (nextDateStr > this.dateRange.latest) {
			console.log("[CHART] At latest date");
			return;
		}

		console.log(`[CHART] Loading next date: ${nextDateStr}`);
		await this._loadPrecipitationData(nextDateStr);
		this.currentPage = 0;
		this._renderChart(this.chartData);
		console.log(`[CHART] Ã¢â€ â€™ Slid to ${nextDateStr} AM`);
	}

	_getWindowLabel() {
		const period = this.currentPage === 0 ? "AM" : "PM";
		return `${this.chartData.date} ${period}`;
	}

	_formatDate(date) {
		const year = date.getFullYear();
		const month = String(date.getMonth() + 1).padStart(2, "0");
		const day = String(date.getDate()).padStart(2, "0");
		return `${year}-${month}-${day}`;
	}

	_updateNavigationButtons() {
		const prevBtn = document.getElementById("btn-prev-day");
		const nextBtn = document.getElementById("btn-next-day");

		if (!prevBtn || !nextBtn) return;

		const isMobile = this._isMobile();

		if (isMobile) {
			const atEarliestDate = this.chartData.date <= this.dateRange.earliest;
			const atLatestDate = this.chartData.date >= this.dateRange.latest;

			const canGoPrev = !(atEarliestDate && this.currentPage === 0);
			const canGoNext = !(
				atLatestDate && this.currentPage === this.totalPages - 1
			);

			prevBtn.style.display = canGoPrev ? "flex" : "none";
			nextBtn.style.display = canGoNext ? "flex" : "none";
		} else {
			if (this.dateRange && this.chartData) {
				const currentDate = this.chartData.date;
				prevBtn.disabled = currentDate <= this.dateRange.earliest;
				nextBtn.disabled = currentDate >= this.dateRange.latest;
			}
		}
	}

	_setupTouchGestures() {
		const chartElement = document.getElementById(this.chartId);
		if (!chartElement) return;

		let touchStartX = 0;
		let touchEndX = 0;

		chartElement.addEventListener(
			"touchstart",
			(e) => {
				touchStartX = e.changedTouches[0].screenX;
			},
			{ passive: true }
		);

		chartElement.addEventListener(
			"touchend",
			(e) => {
				touchEndX = e.changedTouches[0].screenX;
				this._handleSwipe(touchStartX, touchEndX);
			},
			{ passive: true }
		);
	}

	_handleSwipe(startX, endX) {
		const swipeThreshold = 50;
		const diff = startX - endX;

		if (Math.abs(diff) < swipeThreshold) return;

		if (diff > 0) {
			this.slideNext();
		} else {
			this.slidePrev();
		}
	}

	// =========================================================================
	// WEATHER ICONS
	// =========================================================================

	_addWeatherIcons() {
		this._clearWeatherIcons();
		if (!this.chart || !this.chartData) return;

		const firstStation = Object.values(this.chartData.stations)[0];
		if (!firstStation || !firstStation.data) return;

		const chartContainer = document.getElementById(this.chartId);
		if (!chartContainer) return;

		const dims = this._getResponsiveDimensions();
		const isMobile = this._isMobile();

		const allDataPoints = firstStation.data;
		const visibleDataPoints = isMobile
			? this._getDataPointsForCurrentPage(allDataPoints)
			: allDataPoints;

		const ICON_INTERVAL = 2;

		visibleDataPoints.forEach((dataPoint, index) => {
			if (index % ICON_INTERVAL !== 0) return;

			const actualIndex = isMobile
				? this.currentPage * this.hoursPerPage + index
				: index;

			let totalRainfall = 0;
			let visibleStations = 0;

			if (this.chart && this.chart.options.data) {
				this.chart.options.data.forEach((series, seriesIndex) => {
					const isVisible =
						typeof series.visible === "undefined" || series.visible;

					if (isVisible) {
						const stationId = series.stationId;
						if (stationId) {
							const stationData =
								this.chartData.stations[stationId].data[actualIndex];
							if (stationData) {
								totalRainfall += stationData.y || 0;
								visibleStations++;
							}
						}
					}
				});
			}

			const avgRainfall =
				visibleStations > 0 ? totalRainfall / visibleStations : 0;
			const iconUrl = this._getWeatherIcon(avgRainfall);

			const icon = document.createElement("img");
			icon.src = iconUrl;
			icon.style.cssText = `
				width: ${dims.iconSize}px;
				height: ${dims.iconSize}px;
				position: absolute;
				pointer-events: none;
				user-select: none;
				z-index: 10;
				filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
				transition: left 0.3s ease, top 0.3s ease;
			`;
			icon.classList.add("weather-icon");
			icon.dataset.index = index;
			icon.title = `${dataPoint.label}: ${avgRainfall.toFixed(1)} mm/hr`;

			chartContainer.appendChild(icon);
			this.weatherIcons.push(icon);
		});

		this._positionWeatherIcons();
	}

	_positionWeatherIcons() {
		if (!this.chart || this.weatherIcons.length === 0) return;

		const dims = this._getResponsiveDimensions();
		const halfIconSize = dims.iconSize / 2;

		this.weatherIcons.forEach((icon) => {
			const dataIndex = parseInt(icon.dataset.index);

			try {
				const xPosition = this.chart.axisX[0].convertValueToPixel(dataIndex);
				const yPosition = this.chart.plotArea.y1 - 25;

				icon.style.left = `${xPosition - halfIconSize}px`;
				icon.style.top = `${yPosition}px`;
			} catch (error) {
				console.warn("[CHART] Icon position error:", error);
			}
		});
	}

	_getWeatherIcon(rainfall) {
		const baseUrl =
			"https://canvasjs.com/wp-content/uploads/images/gallery/gallery-overview/";
		return rainfall > 0 ? `${baseUrl}rainy.png` : `${baseUrl}sunny.png`;
	}

	_clearWeatherIcons() {
		this.weatherIcons.forEach((icon) => {
			if (icon.parentNode) {
				icon.parentNode.removeChild(icon);
			}
		});
		this.weatherIcons = [];
	}

	// =========================================================================
	// TOOLTIP - CORRECTED DUPLICATE COUNTING
	// =========================================================================

	_formatTooltip(e) {
		if (!e.entries || e.entries.length === 0) return "";

		const isMobile = this._isMobile();
		const width = window.innerWidth;

		// MUCH SMALLER on mobile - won't cover the chart lines!
		let tooltipWidth = "280px"; // Desktop default
		if (width < 480) {
			tooltipWidth = "180px"; // Extra small screens
		} else if (width < 768) {
			tooltipWidth = "200px"; // Mobile
		}

		let html = `<div class="prec-tooltip" style="width: ${tooltipWidth};">`;

		const firstPoint = e.entries[0].dataPoint;
		const timeLabel = firstPoint.actualLabel || firstPoint.label;
		const dayLabel = firstPoint.day || "Today";

		html += `
			<div class="prec-tooltip__header">
				${dayLabel} ${timeLabel}
			</div>
		`;

		// Ã¢Å¡ Ã¯Â¸Â CORRECTED DUPLICATE COUNTING
		const valueGroups = new Map(); // Group by value

		e.entries.forEach((entry) => {
			const rainfall = entry.dataPoint.y;
			const roundedValue = rainfall.toFixed(2); // Use 2 decimals for comparison

			if (!valueGroups.has(roundedValue)) {
				valueGroups.set(roundedValue, []);
			}
			valueGroups.get(roundedValue).push(entry);
		});

		// Find if any value has duplicates
		let maxDuplicateCount = 0;
		let duplicateValue = null;

		valueGroups.forEach((entries, value) => {
			if (entries.length > 1 && entries.length > maxDuplicateCount) {
				maxDuplicateCount = entries.length;
				duplicateValue = value;
			}
		});

		// Show warning ONLY if there are actual duplicates
		if (maxDuplicateCount > 1) {
			html += `
				<div class="prec-tooltip__warning">
					<i class="fas fa-exclamation-triangle"></i>
					<span>${maxDuplicateCount} stations reporting identical values</span>
				</div>
			`;
		}

		html += `<div class="prec-tooltip__body">`;

		e.entries.forEach((entry) => {
			const color = entry.dataSeries.color;
			const name = entry.dataPoint.stationName || entry.dataSeries.name;
			const rainfall = entry.dataPoint.y;

			const displayValue =
				rainfall === 0 ? "No Rain" : `${rainfall.toFixed(2)} mm/hr`;
			const valueColor = rainfall === 0 ? "#94a3b8" : color;

			html += `
				<div class="prec-tooltip__station">
					<div class="prec-tooltip__station-left">
						<span class="prec-tooltip__dot" style="background: ${color};"></span>
						<span class="prec-tooltip__station-name">${name}:</span>
					</div>
					<span class="prec-tooltip__value" style="color: ${valueColor};">
						${displayValue}
					</span>
				</div>
			`;
		});

		html += `</div></div>`;
		return html;
	}

	// =========================================================================
	// UI STATE
	// =========================================================================

	_showLoading() {
		if (this.elements.loading) {
			this.elements.loading.classList.remove("hidden");
		}
		this._hideError();
	}

	_hideLoading() {
		if (this.elements.loading) {
			this.elements.loading.classList.add("hidden");
		}
	}

	_showError(message) {
		if (this.elements.errorMessage) {
			this.elements.errorMessage.textContent = message;
		}
		if (this.elements.error) {
			this.elements.error.classList.add("show");
		}
		if (this.elements.chartContainer) {
			this.elements.chartContainer.style.display = "none";
		}
		this._hideLoading();
	}

	_hideError() {
		if (this.elements.error) {
			this.elements.error.classList.remove("show");
		}
		if (this.elements.chartContainer) {
			this.elements.chartContainer.style.display = "block";
		}
	}
}

// Export
if (typeof module !== "undefined" && module.exports) {
	module.exports = PrecipitationChart;
} else {
	window.PrecipitationChart = PrecipitationChart;
}
